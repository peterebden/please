// This file was originally generated by genx (https://github.com/OneOfOne/genx)
// but has a large set of manual changes made later, and hence is more inspired by
// the original than generated from it.

package core

import (
	"sync"

	"github.com/OneOfOne/cmap/hashers"
)

// shardCount must be a power of 2.
// Higher shardCount will improve concurrency but will consume more memory.
const shardCount = 1 << 8

// shardMask is the mask we apply to hash functions below.
const shardMask = shardCount - 1

// targetMap is a concurrent safe sharded map to scale on multiple cores.
// It's a fully specialised version of cmap.CMap for our most commonly used types.
type targetMap struct {
	shards []*targetLMap
}

// newTargetMap creates a new targetMap.
func newTargetMap() *targetMap {
	cm := &targetMap{
		shards: make([]*targetLMap, shardCount),
	}
	for i := range cm.shards {
		cm.shards[i] = newTargetLMapSize(shardCount)
	}
	return cm
}

// Set is the equivalent of `map[key] = val`.
// It returns true if the item was inserted, false if it already existed (in which case it won't be inserted)
func (cm *targetMap) Set(t *BuildTarget) bool {
	h := hashBuildLabel(t.Label)
	return cm.shards[h&shardMask].Set(h, t)
}

// GetOK is the equivalent of `val, ok := map[key]`.
func (cm *targetMap) GetOK(key BuildLabel) (val *BuildTarget, ok bool) {
	h := hashBuildLabel(key)
	return cm.shards[h&shardMask].GetOK(h, key)
}

// Values returns a slice of all the current values in the map.
// This is a view that an observer could potentially have had at some point around the calling of this function,
// but no particular consistency guarantees are made.
func (cm *targetMap) Values() BuildTargets {
	ret := BuildTargets{}
	for _, lm := range cm.shards {
		ret = append(ret, lm.Values()...)
	}
	return ret
}

func hashBuildLabel(key BuildLabel) uint32 {
	return hashers.Fnv32(key.Subrepo) ^ hashers.Fnv32(key.PackageName) ^ hashers.Fnv32(key.Name)
}

// targetLMap is a threadsafe hashmap used by targetMap internally for sharding.
// It uses an append-only implementation of Robin Hood hashing internally.
type targetLMap struct {
	buckets []entry
	mask    int
	size    int
	maxSize int
    maxDib  int
	dib     int
	l sync.RWMutex
}

// newTargetLMapSize is the equivalent of `m := make(map[BuildLabel]*BuildTarget, cap)`
func newTargetLMapSize(cap int) *targetLMap {
	lm := &targetLMap{}
	lm.resize(cap)
	return lm
}

func (lm *targetLMap) resize(cap int) {
	const maxLoadFactor = 0.8
	const maxAverageDib = 2

	old := lm.buckets
	lm.buckets = make([]entry, cap)
	lm.mask = cap - 1
	lm.maxSize = int(float64(cap) * maxLoadFactor)
	lm.maxDib = maxAverageDib * cap
	lm.dib = 0
	for _, b := range old {
		dib, _ := lm.set(b.Hash, b.Target)
		lm.dib += int(dib)
	}
}

// Set is the equivalent of `map[key] = val`.
// It returns true if the item was inserted, false if it already existed (in which case it won't be inserted)
func (lm *targetLMap) Set(h uint32, v *BuildTarget) bool {
	lm.l.Lock()
	defer lm.l.Unlock()
	if lm.size == lm.maxSize || lm.dib >= lm.maxDib {
		lm.resize(len(lm.buckets) * 2)
	}
	dib, inserted := lm.set(h, v)
	lm.dib += int(dib)
	if inserted {
		lm.size++
	}
	return inserted
}

func (lm *targetLMap) set(h uint32, v *BuildTarget) (uint32, bool) {
	var dib, extraDib uint32
	for i := int(h) & lm.mask; ; i = (i + 1) & lm.mask {
		if e := lm.buckets[i]; e.Target == nil {
			// This slot is available, insert here
			lm.buckets[i] = entry{
				Target: v,
				Hash:   h,
				DIB:    dib,
			}
			return extraDib, true
		} else if dib > e.DIB {
			// Our current dib is worse than this one, displace it and continue.
			newe := entry{
				Target: v,
				Hash:   h,
				DIB:    dib,
			}
			v = e.Target
			h = e.Hash
			dib = e.DIB
			lm.buckets[i] = newe
		} else if e.Hash == h && e.Target.Label == v.Label {
			return extraDib, false  // duplicate target
		}
		// Couldn't insert, our dib goes up and we continue.
		dib++
		extraDib++
	}
}

// GetOK is the equivalent of `val, ok := map[key]`.
func (lm *targetLMap) GetOK(h uint32, key BuildLabel) (*BuildTarget, bool) {
	lm.l.RLock()
	defer lm.l.RUnlock()
	// TODO(peterebden): Is it worth checking the DIB here?
	for i := int(h) & lm.mask; ; i = (i + 1) & lm.mask {
		if e := lm.buckets[i]; e.Hash == h && e.Target.Label == key {
			return e.Target, true
		} else if e.Target == nil {
			return nil, false
		}
	}
}

// Values returns a copy of all the values currently in the map.
func (lm *targetLMap) Values() []*BuildTarget {
	lm.l.RLock()
	defer lm.l.RUnlock()
	ret := make([]*BuildTarget, 0, lm.size)
	for _, e := range lm.buckets {
		if e.Target != nil {
			ret = append(ret, e.Target)
		}
	}
	return ret
}

type entry struct{
	Target *BuildTarget
	Hash   uint32
	DIB    uint32
}

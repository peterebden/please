// This file was originally generated by genx (https://github.com/OneOfOne/genx)
// but has a large set of manual changes made later.

package core

import (
	"sync"

	"github.com/OneOfOne/cmap/hashers"
)

// targetMap is a concurrent safe sharded map to scale on multiple cores.
// It's a fully specialised version of cmap.CMap for our most commonly used types.
type targetMap struct {
	shards []*targetLMap
}

// newTargetMap creates a new targetMap.
func newTargetMap() *targetMap {
	// shardCount must be a power of 2.
	// Higher shardCount will improve concurrency but will consume more memory.
	const shardCount = 1 << 8

	cm := &targetMap{
		shards: make([]*targetLMap, shardCount),
	}
	for i := range cm.shards {
		cm.shards[i] = newTargetLMapSize(shardCount)
	}
	return cm
}

// Set is the equivalent of `map[key] = val`.
// It returns true if the item was inserted, false if it already existed (in which case it won't be inserted)
func (cm *targetMap) Set(key BuildLabel, val *BuildTarget) bool {
	h := hashBuildLabel(key)
	return cm.shards[h&uint32(len(cm.shards)-1)].Set(key, val)
}

// GetOK is the equivalent of `val, ok := map[key]`.
func (cm *targetMap) GetOK(key BuildLabel) (val *BuildTarget, ok bool) {
	h := hashBuildLabel(key)
	return cm.shards[h&uint32(len(cm.shards)-1)].GetOK(key)
}

// ForEachLocked loops over all the key/values in the map.
// You can break early by returning false.
// It is **NOT* safe to modify the map while using this iterator.
func (cm *targetMap) ForEachLocked(fn func(key BuildLabel, val *BuildTarget)) {
	for _, lm := range cm.shards {
		lm.ForEachLocked(fn)
	}
}

func hashBuildLabel(key BuildLabel) uint32 {
	return hashers.Fnv32(key.Subrepo) ^ hashers.Fnv32(key.PackageName) ^ hashers.Fnv32(key.Name)
}

// targetLMap is a simple sync.RWMutex locked map.
// Used by targetMap internally for sharding.
type targetLMap struct {
	m map[BuildLabel]*BuildTarget
	l sync.RWMutex
}

// newTargetLMapSize is the equivalent of `m := make(map[BuildLabel]*BuildTarget, cap)`
func newTargetLMapSize(cap int) *targetLMap {
	return &targetLMap{
		m: make(map[BuildLabel]*BuildTarget, cap),
	}
}

// Set is the equivalent of `map[key] = val`.
// It returns true if the item was inserted, false if it already existed (in which case it won't be inserted)
func (lm *targetLMap) Set(key BuildLabel, v *BuildTarget) bool {
	lm.l.Lock()
	defer lm.l.Unlock()
	if _, present := lm.m[key]; present {
		return false
	}
	lm.m[key] = v
	return true
}

// GetOK is the equivalent of `val, ok := map[key]`.
func (lm *targetLMap) GetOK(key BuildLabel) (*BuildTarget, bool) {
	lm.l.RLock()
	defer lm.l.RUnlock()
	v, ok := lm.m[key]
	return v, ok
}

// ForEachLocked loops over all the key/values in the map.
// It is **NOT* safe to modify the map while using this iterator.
func (lm *targetLMap) ForEachLocked(fn func(key BuildLabel, val *BuildTarget)) {
	lm.l.RLock()
	defer lm.l.RUnlock()
	for key, val := range lm.m {
		fn(key, val)
	}
}
